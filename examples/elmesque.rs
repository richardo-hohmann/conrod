//!
//! This example shows how to use conrod together with custom elmesque drawing.
//!


#[macro_use] extern crate conrod;
extern crate elmesque;
extern crate find_folder;
extern crate piston_window;


use conrod::{Colorable, Labelable, Slider, Widget};
use piston_window::{Glyphs, OpenGL, PistonWindow, UpdateEvent, WindowSettings};
use std::iter::once;
use std::ops::DerefMut;


fn main() {

    // PistonWindow has two type parameters, but the default type is
    // PistonWindow<T = (), W: Window = GlutinWindow>. To change the Piston backend,
    // specify a different type in the let binding, e.g.
    // let window: PistonWindow<(), Sdl2Window>.
    let window: PistonWindow = WindowSettings::new("Control Panel", [1200, 800])
        .opengl(OpenGL::V3_2)
        .exit_on_esc(true)
        .build().unwrap();

    // Conrod's main object.
    let mut ui = {
        // Load a font. Glyphs is provided by piston_window and gfx. Other Piston backends provide
        // similar types.
        let assets = find_folder::Search::ParentsThenKids(3, 3)
            .for_folder("assets").unwrap();
        let font_path = assets.join("fonts/NotoSans/NotoSans-Regular.ttf");
        let glyph_cache = Glyphs::new(&font_path, window.factory.borrow().clone()).unwrap();
        conrod::Ui::new(glyph_cache, conrod::Theme::default())
    };

    // Total time elapsed since the app started. We'll use this for animation.
    let mut secs: f64 = 0.0;

    // A value controlled by our slider.
    let mut slider_val: f64 = 50.0;

    // We'll use this to store the latest elmesque `Element` generated by the `Ui`.
    let mut maybe_ui_form = None;

    for e in window {
        // Pass each `Event` to the `Ui`.
        ui.handle_event(&e.event.clone().unwrap());

        e.draw_2d(|c, g| {

            // Our unique `WidgetId`s! In this case, we only have one (for our slider below).
            widget_ids!(SLIDER);

            // Create a Conrod slider widget.
            Slider::new(slider_val, 0.0, 500.0)
                .color(conrod::color::rgb(0.0, 0.3, 0.1))
                .label_color(conrod::color::white())
                .label("Example Slider")
                .react(|val| slider_val = val)
                .set(SLIDER, &mut ui);

            // `.element_if_changed` will return `Some` new `Element` representing a view of the
            // entire `Ui` either if it is being called for the first time or if there was some
            // visible change in the `Ui`'s state.
            if let Some(new_ui_element) = ui.element_if_changed() {
                maybe_ui_form = Some(elmesque::form::to_form(new_ui_element.clone()));
            }

            // Elmesque needs a GlypheCache instance. Above, we moved the GlypheCache
            // into the conrod::Ui, so we'll borrow the GlypheCache from there.
            // conrod::Ui wraps the character cache in a RefCell and a conrod::GlypheCache. 
            let mut cc_ref_mut = ui.glyph_cache.deref_mut().borrow_mut();

            // Elmesque's renderer. Conrod also uses one of these under the hood, but
            // we can't access that one, so we instantiate our own.
            let mut renderer = elmesque::Renderer::new(c, g)
                .character_cache(cc_ref_mut.deref_mut());

            // Create a renderable elmesque rectangle `Form`.
            let rect_form = elmesque::form::rect(60.0, 40.0)
                .filled(elmesque::color::blue())
                .shift(secs.sin() * slider_val, secs.cos() * slider_val);

            // Get the window dimensions.
            let view_dim = c.get_view_size();
            let (w, h) = (view_dim[0] as i32, view_dim[1] as i32);

            // Collect the forms for our rectangle and the Ui into a single Vec. 
            let forms = once(rect_form).chain(maybe_ui_form.clone()).collect();

            // Render the Elmesque rectangle.
            elmesque::form::collage(w, h, forms)
                .clear(elmesque::color::black())
                .draw(&mut renderer);
        });

        e.update(|args| secs += args.dt);
    }
}

